{"pages":[],"posts":[{"title":"Http协议 & Servlet","text":"Http协议 什么是协议 双方在交互、通讯的时候，遵守的一种规范、规则。 Http协议 针对网络上的客户端与服务器端在执行http请求的时候，遵守的一种规范。其实就是规定了客户端在访问服务器端的时候，要带上哪些东西，服务器端返回数据的时候，也要带上什么东西。 版本 1.0 ​ 请求数据，服务器返回后，将会断开连接 1.1 ​ 请求数据，服务器返回后，连接还会保持着。除非服务器或者客户端关掉。有一定的时间限制，如果都空着这个连接，那么后面会自己断掉。 演示客户端如何与服务器端通讯 在地址栏中键入网络地址或者是平常注册的时候，点击了注册按钮，浏览器都能显示出来一些东西。那么背地里到底浏览器和服务器是怎么通讯，它们都传输了哪些数据呢？ Http请求数据解释 请求的数据里面包含三个部分内容：请求行、请求头、请求体 请求行 1POST：请求方式，以post去提交数据 请求头 请求体 浏览器真正发送给服务器的数据 12发送的数据呈现的是key=value，如果存在多个数据，那么使用&amp;firstname=zhang&amp;lastname=san Http响应数据解析 响应的数据里面包含三个部分的内容：响应行、响应头、响应体 GET和POST的区别 请求路径不同。POST请求，在URL后面不跟上任何的数据，GET请求在地址后面跟上数据 带上的数据不同。POST请求会使用流的方式写数据，GET请求是在地址栏上跟数据 由于POST请求使用流的方式写数据，所以一定要一个Content-Length的头来说明数据的长度有多少。 POST 数据是以流的方式写过去，不会在地址栏上面显示。现在一般提交数据到服务器使用的都是POST。 以流的方式写数据，所有数据没有大小限制。 GET 会在地址栏后面拼接数据，所以有安全隐患。一般从服务器获取数据，并且客户端也不用提交上面的数据的时候，可以使用GET。 能够带的数据有限，1kb大小 Web资源在http协议当中，规定了请求和响应双方，客户端和服务器端。与Web相关的资源叫Web资源。 有两种分类： 静态资源 html、js、css 动态资源 servlet、jsp Servlet Servlet是什么？ 其实就是一个java程序，运行在我们的Web服务器上，用于接收和响应客户端的http请求。 更多的是配合动态资源来做，当然静态资源也需要使用到Servlet，只不过是Tomcat里面已经定义好了一个DefaultServlet。 Hello Servlet 得写一个Web工程，要有一个服务器。 测试运行Web工程 新建一个类，实现Servlet接口 配置Servlet，用意：告诉服务器，我们的应用有这么写个Servlet。 在web\\WEB-INF\\web.xml里面写上以下内容 12345678910&lt;!-- 向Tomcat报告，这个应用里面有个Servlet，名字叫做HelloServlet，具体的路径是com.wjh.servlet.HelloServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wjh.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 注册Servlet的映射。Servlet-name：找到上面注册的具体Servlet，url-pattern：在地址栏上的path --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet执行过程 找到Tomcat应用 找到项目 找web.xml，然后在里面找到url-pattern，看有没有哪一个pattern的内容是/helloServlet 找到servlet-mapping中的哪个servlet-name 【HelloServlet】 找到上面定义的servlet元素中的servlet-name中的【HelloServlet】 找到下面定义的servlet-class，然后开始创建该类的实例 继而执行该Servlet中的service方法 Servlet的通用写法12345Servlet（接口） |GenericServlet |HttpServlet（用于处理http的请求） 定义一个类，继承HttpServlet，复写doGet和doPost Servlet的生命周期 生命周期 从创建到销毁的一段时间 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 123//在创建该Servlet的实例时，就执行该方法。 //一个Servlet只会初始化一次，即init方法只会执行一次 //默认情况下是：初次访问该Servlet时，才会创建实例 service方法 12//只要客户端来了一个请求，那么就执行这个方法 //该方法可以被执行很多次。一次请求对应一次service方法的调用。 destroy方法 123//Servlet销毁的时候，就会执行该方法 //1.该项目从Tomcat里面移除 //2.正常关闭Tomcat就会执行 doGet和doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法，但是这两个方法，不一定会执行。 让Servlet创建实例的时机提前 默认情况下，只有在初次访问Servlet的时候，才会执行init方法。有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次方法可能会在init方法中逗留太久的时间。那么有没有方法可以让这个初始化的时机提前一点呢？ 在配置的时候，使用load-on-startup元素来指定，给定的数据越小，启动的时机就越早，一般不写负数，从2开始即可。 12345&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wjh.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; ServletConfig Servlet的配置，通过这个对象，可以获取Servlet在配置的时候的一些信息 1234567891011121314151617181920//ServletConfig 专门用于在配置Servlet的信息//1.得到Servlet配置对象ServletConfig config = getServletConfig();//获取到的是配置Servlet里面servlet-name的文本内容String servletName = config.getServletName();System.out.println(\"servletName = \" + servletName); //2.可以获取具体的某一个参数 String address = config.getInitParameter(\"address\"); System.out.println(\"address = \" + address); //3.获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) { String key = names.nextElement(); String parameter = config.getInitParameter(key); System.out.println(\"name = \" + key + \", value = \" + parameter); } 为什么需要有这个ServletConfig 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码我们不会，但是有人写出来了。它的代码放置在了自己的Servlet类里面。 刚好这个Servlet里面需要一个数字或者叫做变量值，但是这个值不能是固定的，所以要求使用到这个Servlet的公司，在注册Servlet的时候，必须要在web.xml里面声明init-params。 总结 Http协议 使用Http抓包看一看http请求背后的细节。 基本了解请求和响应的数据内容 12请求行、请求头、请求体响应行、响应头、响应体 GET和POST的区别 Servlet 会使用简单的Servlet 写一个类，实现接口Servlet 配置Servlet 会访问Servlet Servlet的生命周期 init service destroy ServletConfig 获取配置的信息，params","link":"/2019/04/24/Http协议-Servlet/"},{"title":"深入理解Java多线程与并发编程","text":"一、线程三大特性​ 多线程有三大特性：原子性、可见性、有序性 1.1、什么是原子性​ 即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性其实就是保证数据一致，线程安全的一部分。 1.2、什么是可见性​ 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 1.3、什么是有序性​ 程序执行的顺序按照代码的先后顺序执行。 二、Java内存模型​ 共享内存模型指的就是Java内存模型（简称JMM），JMM决定一个线程对共享变量的写入时，能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并且真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 ​ 总结：什么是Java内存模型：Java内存模型简称JMM，定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。 三、Volatile4.1、什么是Volatile​ Volatile关键字的作用是变量在多个线程之间可见。 1public volatile boolean flag = true; ​ 使用Volatile关键字可以解决线程之间的可见性，强制线程每次读取该值的时候都去“主内存”中取值。 4.2、Volatile非原子性123456789101112131415161718192021public class VolatileNoAtomicDemo { public static void main(String[] args) { for (int i = 0; i &lt; 10; i++) { VolatileNoAtomoic[] volatileNoAtomoics = new VolatileNoAtomoic[10]; volatileNoAtomoics[i] = new VolatileNoAtomoic(); volatileNoAtomoics[i].start(); } }}class VolatileNoAtomoic extends Thread { private static int count = 0; @Override public void run() { for (int i = 0; i &lt; 1000; i++) { count++; } System.out.println(getName() + \"---&gt;\" + count); }} 4.3、使用AtomicInterger原子类1234567891011class VolatileNoAtomoic extends Thread { private static AtomicInteger atomicInteger = new AtomicInteger(0); @Override public void run() { for (int i = 0; i &lt; 1000; i++) { atomicInteger.incrementAndGet(); //相当于count++ } System.out.println(getName() + \"---&gt;\" + atomicInteger); }} 4.4、volatile与synchronized区别​ 紧靠volatile不能保证线程的安全性。（原子性） ​ ①volatile轻量级，只能修饰变量。synchronized重量级，还可以修饰方法。 ​ ②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量时不会阻塞。synchronized不仅可以保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。 ​ 线程安全性：线程安全性包括两个方面：①可见性，②原子性。 五、ThreadLocal5.1、什么是ThreadLocal​ ThreadLocal提高一个线程的局部变量，访问某个线程拥有自己的局部变量。 ​ 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本变量。 1234567private ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;Integer&gt;() { //设置当前线程局部变量初始化值 @Override protected Integer initialValue() { return 0; } }; 5.2、ThreadLocal实现原理​ ThreadLocal通过map集合 Map.put(“当前线程”, 值) 六、线程池6.1、什么是线程池？6.2、线程池的作用6.3、线程池四种创建方式​ Java通过Executors（jdk1.5并发包）提供四种线程池，分别为： newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 1ExecutorService newCacheThreadPool = Executors.newCachedThreadPool(); newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 12//每次最多执行3个线程ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(3); newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor（一般不使用）：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序运行。 ​ 总结：线程池为无限大，当执行第二个任务时第一个任务已经完成，会重复用执行第一个任务的线程，而不用每次新建线程。","link":"/2019/04/24/深入理解Java多线程与并发编程/"},{"title":"JDBC","text":"Java Database Connectivity：Java 数据库连接 为什么会出现JDBC Sun公司提供的一种数据库访问规则、规范，由于数据库种类较多，并且Java语言使用比较广泛，Sun公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。Java程序只要使用Sun公司提供的JDBC驱动即可。 使用JDBC的基本步骤 注册驱动 12//1.注册驱动 DriverManager.registerDriver(new Driver()); 建立连接 12//2.建立连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost/student?serverTimezone=GMT\", \"root\", \"root\"); 创建statement 12//3.创建statement，跟数据库打交道，一定需要这个对象 st = conn.createStatement(); 执行sql，得到ResultSet 123//4.执行查询，得到结果集 String sql = \"select * from student\"; rs = st.executeQuery(sql); 遍历查询结果 12345678//5.遍历查询每一条记录 while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); System.out.println(\"id=\" + id + \", name=\" + name + \", age=\" + age); } 释放资源 1234567try { if (rs != null) { rs.close(); } } catch (SQLException e) { e.printStackTrace(); } 入门代码 123456789101112131415161718192021222324252627282930313233343536import com.mysql.cj.jdbc.Driver;import java.sql.*;public class MainTest { public static void main(String[] args) { try { //1.注册驱动 DriverManager.registerDriver(new Driver()); //2.建立连接 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/student?serverTimezone=GMT\", \"root\", \"root\"); //3.创建statement，跟数据库打交道，一定需要这个对象 Statement st = conn.createStatement(); //4.执行查询，得到结果集 String sql = \"select * from student\"; ResultSet rs = st.executeQuery(sql); //5.遍历查询每一条记录 while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); System.out.println(\"id=\" + id + \", name=\" + name + \", age=\" + age); } } catch (SQLException e) { e.printStackTrace(); } finally { //JDBCUtil为手写的JDBC工具类，release为释放资源的方法 JDBCUtil.release(conn, st, rs); } }} JDBC 工具类构建 资源释放工作的整合 驱动防二次注册 12345//DriverManager.registerDriver(new Driver());//Driver 这个类里面有静态代码快，只要类加载了就执行，所以等同于注册了两次驱动，其实没这个必要的。//静态代码块 ---&gt; 类加载了，就执行 DriverManager.registerDriver(new Driver());//最后形成以下代码即可Class.forName(\"com.mysql.cj.jdbc.Driver\"); 使用properties配置文件 在src底下声明一个资源文件 xxx.properties ，里面的内容如下： 1234driverClass=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost/student?serverTimezone=GMTuserName=rootuserPassword=root 在工具类里面，使用静态代码块读取属性 1234567891011121314151617181920static { try { //创建一个属性配置对象 Properties properties = new Properties(); //使用类加载器，去读取src低下的资源文件 InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); //导入输入流 properties.load(is); //读取属性 driverClass = properties.getProperty(\"driverClass\"); url = properties.getProperty(\"url\"); userName = properties.getProperty(\"userName\"); userPassword = properties.getProperty(\"userPassword\"); } catch (IOException e) { e.printStackTrace(); } } 数据库的CRUD sql insert 12INSERT INTO student (NAME, age) VALUES ('wangqiang', 28)INSERT INTO student VALUES (NULL, 'lidazui', 33) delete 1DELETE FROM student WHERE id = 5 query 1SELECT * FROM student update 1UPDATE student SET age = 38 WHERE id = 1 使用单元测试，测试代码 定义一个类，TestXXX，里面定义方法 testXXX 添加Junit的支持 在方法的上面加上注解，其实就是一个标记 1234@Test public void testQuery() { } 执行单元测试 DAO模式 Data Access Object 数据访问对象 新建一个Dao的接口，里面声明数据库访问规则 1234567public interface UserDao { /** * @Description 查询所有 **/ void findAll();} 新建一个Dao的实现类，具体实现早前定义的规则 123456789101112131415161718192021222324public class UserDaoImpl implements UserDao { @Override public void findAll() { Connection conn = null; Statement st= null; ResultSet rs = null; try { conn = JDBCUtil.getConnection(); st = conn.createStatement(); String sql = \"select * from user\"; rs = st.executeQuery(sql); while (rs.next()) { String userName = rs.getString(\"username\"); String password = rs.getString(\"password\"); System.out.println(\"userName:\" + userName + \", password=\" + password); } } catch (SQLException e) { e.printStackTrace(); } finally { JDBCUtil.release(conn, st, rs); } }} 直接使用实现 12345@Test public void tsetFindAll() { UserDao dao = new UserDaoImpl(); dao.findAll(); } Statement安全问题 Statement执行，其实是拼接sql语句的，先拼接sql语句，然后再一起执行 123456789String sql = \"select * from user where username = '\" + userName + \"' and password = '\" + password + \"'\";UserDao dao = new UserDaoImpl();dao.login(\"admin\", \"10000086' or '1=1\");SELECT * FROM user WHERE username='admin' AND password='10000086' or '1=1'//前面先拼接sql语句，如果变量里面带有了数据库的关键字，那么一并认为是关键字，不认为是普通的字符串rs = st.executeQuery(sql); PrepareStatement 该对象就是替换前面的statement对象 相比较以前的statement，PrepareStatement预先处理给定的sql语句，对其执行语法检查。在sql语句里面使用 ？占位符来替代后续要传递进来的变量。后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。 123456String sql = \"insert into user values (null, ?, ?)\";ps = conn.prepareStatement(sql); //给占位符赋值，从左到右数过来，1代表第一个问号，永远从1开始。ps.setString(1, userName);ps.setString(2, password); 总结： JDBC入门 抽取工具类 Statement CRUD 1演练CRUD DAO模式 1声明与实现分开 PrepareStatement CRUD 1预处理sql语句，解决上面Statement出现的问题","link":"/2019/04/25/JDBC/"},{"title":"继承——类、超类和子类","text":"1.1 定义子类1234public class Manager extends Employee{true添加方法和域} ​ 关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class）或孩子类（child class）。 ​ 在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该讲通用的方法放在超类中，而将具有特殊用途的方法放在子类中，这种将通用的功能放到超类的做法，在面向对象程序设计中十分普遍。 1.2 覆盖方法​ 超类中的有些方法对子类并不一定适用，因此，需要提供一个新的方法来覆盖（override）超类中的某些方法。 1.3 子类构造器12345public Manager(String name, double salary, int year, int month, int day){truesuper(name, salary, year, month, day); //调用超类Employee中含有name，salary，year，month和day参数的构造器truebouns = 0;} ​ 由于Manager类的构造器不能访问Employee类的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化，我们可以通过super实现对超类构造器的调用。使用super调用构造器的语句必须是子类构造器的第一条语句。 ​ 如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。 1.4 继承层次​ 继承并不仅限于一个层次。例如，可以由Manager类派生Executive类。由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy），如图所示。在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承连（inheritance chain）。 ​ 通常，一个祖先类可以拥有多个子孙继承连。例如，可以由Employee类派生出子类Programmer或Secretary，它们与Manager类没有任何关系（有可能它们彼此之间也没有任何关系）。必要的话，可以将这个过程一直延续下去。 1.5 多态​ 有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a”规则，它表明子类的每个对象也是超类的对象。例如，每个经理都是雇员，因此，将Manager类设计为Employee类的子类是显而易见的，反之不然，并不是每一名雇员都是经理。 ​ “is-a”规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象转换。 ​ 例如，可以将一个子类的对象赋给超类变量。 123Employee e;e = new Employee(...);e = new Manager(...); ​ 在Java程序设计语言中，对象变量是多态的。一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象（例如，Manager、Executive、Secretary等）。然而，不能将一个超类的引用赋给子类变量。 1.6 理解方法调用​ 弄清楚如何在对象上应用方法调用非常重要。下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述： 编译器查看对象的声明类型和方法名。假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是：有可能存在多个名字为f，但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。 至此，编译器已获得所有可能被调用的候选方法。 接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析（overloading resolution）。例如，对于调用x.f(“Hello”)来说，编译器将会挑选f(String)，而不是f(int)。由于允许类型转换（int可以转换成double，Manager可以转换成Employee，等等），所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。 至此，编译器已获得需要调用的方法名字和参数类型。 如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定（static binding）。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。 每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方发表（method table），其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。 1.7 阻止继承：final类和方法​ 有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。 ​ 类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）。 ​ 将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。例如，String类是final类，这意味着不允许任何人定义String的子类。换言之，如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。 1.8 强制类型转换​ 对象引用的转换语法与数值表达式的类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。例如： 1Manager boss = (Manager) staff[0]; ​ 进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。 ​ 将一个值存入变量时，编译器将检查是否允许该操作。将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。 ​ 综上所述： 只能在继承层次内进行类型转换。 在将超类转换成子类之前，应该使用instanceof进行检查。 12345if (staff[1] instanceof Manager){trueboss = (Manager) staff[1];true...} 在一般情况下，应该尽量少用类型转换和instanceof运算符。 1.9 抽象类​ 如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。 ​ 包含一个或多个抽象方法的类本身必须被声明为抽象的。 12345public abstract class Person{true...truepublic abstract String getDescription();} ​ 除了抽象方法之外，抽象类还可以包含具体数据和具体方法。例如，Person类还保存着姓名和一个返回姓名的具体方法。 123456789101112131415public abstract class Person{trueprivate String name;truepublic Person(String name) {truetruethis.name = name;true}truetruepublic abstract String getDescription();truetruepublic String getName() {truetruereturn name;true}} 许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中。 ​ 抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。 1.10 受保护访问​ 在有些时候，人们希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为protected。 ​ 在实际应用中，要谨慎使用protected属性。假设需要将设计的类提供给其他程序员使用，而在这个类中设置了一些受保护域，由于其他程序员可以由这个类在派生出新类，并访问其中的受保护欲。在这种情况下，如果需要对这个类的实现进行修改，就必须通知所有使用这个类的程序员。这违背了OOP提倡的数据封装原则。 ​ 受保护的方法更具有实际意义。如果需要限制某个方法的使用，就可以将它声明为protected。这表明子类（可能很熟悉祖先类）得到信任，可以正确地使用这个方法，而其他类则不行。 ​ Java用于控制可见性的4个访问修饰符： 仅对本类可见——private 对所有类可见——public 对本包和所有子类可见——protected 对本包可见——默认，不需要修饰符","link":"/2019/05/07/继承——类、超类和子类/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Java核心技术卷一","slug":"Java核心技术卷一","link":"/tags/Java核心技术卷一/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/笔记/"}]}