{"meta":{"title":"wangjh626’s Blog","subtitle":null,"description":null,"author":"wangjh626","url":"https://wangjh626.github.io","root":"/"},"pages":[],"posts":[{"title":"深入理解Java多线程与并发编程","slug":"深入理解Java多线程与并发编程","date":"2019-04-24T04:43:41.000Z","updated":"2019-04-24T04:44:09.711Z","comments":true,"path":"2019/04/24/深入理解Java多线程与并发编程/","link":"","permalink":"https://wangjh626.github.io/2019/04/24/深入理解Java多线程与并发编程/","excerpt":"","text":"深入理解Java多线程与并发编程一、线程三大特性​ 多线程有三大特性：原子性、可见性、有序性 1.1、什么是原子性​ 即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性其实就是保证数据一致，线程安全的一部分。 1.2、什么是可见性​ 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 1.3、什么是有序性​ 程序执行的顺序按照代码的先后顺序执行。 二、Java内存模型​ 共享内存模型指的就是Java内存模型（简称JMM），JMM决定一个线程对共享变量的写入时，能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并且真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 ​ 总结：什么是Java内存模型：Java内存模型简称JMM，定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。 三、Volatile4.1、什么是Volatile​ Volatile关键字的作用是变量在多个线程之间可见。 1public volatile boolean flag = true; ​ 使用Volatile关键字可以解决线程之间的可见性，强制线程每次读取该值的时候都去“主内存”中取值。 4.2、Volatile非原子性123456789101112131415161718192021public class VolatileNoAtomicDemo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; VolatileNoAtomoic[] volatileNoAtomoics = new VolatileNoAtomoic[10]; volatileNoAtomoics[i] = new VolatileNoAtomoic(); volatileNoAtomoics[i].start(); &#125; &#125;&#125;class VolatileNoAtomoic extends Thread &#123; private static int count = 0; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; count++; &#125; System.out.println(getName() + \"---&gt;\" + count); &#125;&#125; 4.3、使用AtomicInterger原子类1234567891011class VolatileNoAtomoic extends Thread &#123; private static AtomicInteger atomicInteger = new AtomicInteger(0); @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; atomicInteger.incrementAndGet(); //相当于count++ &#125; System.out.println(getName() + \"---&gt;\" + atomicInteger); &#125;&#125; 4.4、volatile与synchronized区别​ 紧靠volatile不能保证线程的安全性。（原子性） ​ ①volatile轻量级，只能修饰变量。synchronized重量级，还可以修饰方法。 ​ ②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量时不会阻塞。synchronized不仅可以保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。 ​ 线程安全性：线程安全性包括两个方面：①可见性，②原子性。 五、ThreadLocal5.1、什么是ThreadLocal​ ThreadLocal提高一个线程的局部变量，访问某个线程拥有自己的局部变量。 ​ 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本变量。 1234567private ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;Integer&gt;() &#123; //设置当前线程局部变量初始化值 @Override protected Integer initialValue() &#123; return 0; &#125; &#125;; 5.2、ThreadLocal实现原理​ ThreadLocal通过map集合 Map.put(“当前线程”, 值) 六、线程池6.1、什么是线程池？6.2、线程池的作用6.3、线程池四种创建方式​ Java通过Executors（jdk1.5并发包）提供四种线程池，分别为： newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 1ExecutorService newCacheThreadPool = Executors.newCachedThreadPool(); newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 12//每次最多执行3个线程ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(3); newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor（一般不使用）：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序运行。 ​ 总结：线程池为无限大，当执行第二个任务时第一个任务已经完成，会重复用执行第一个任务的线程，而不用每次新建线程。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-24T02:45:35.876Z","updated":"2019-04-24T02:45:35.876Z","comments":true,"path":"2019/04/24/hello-world/","link":"","permalink":"https://wangjh626.github.io/2019/04/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}