{"pages":[],"posts":[{"title":"JDBC","text":"Java Database Connectivity：Java 数据库连接 为什么会出现JDBC Sun公司提供的一种数据库访问规则、规范，由于数据库种类较多，并且Java语言使用比较广泛，Sun公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。Java程序只要使用Sun公司提供的JDBC驱动即可。 使用JDBC的基本步骤 注册驱动 12//1.注册驱动 DriverManager.registerDriver(new Driver()); 建立连接 12//2.建立连接 conn = DriverManager.getConnection(\"jdbc:mysql://localhost/student?serverTimezone=GMT\", \"root\", \"root\"); 创建statement 12//3.创建statement，跟数据库打交道，一定需要这个对象 st = conn.createStatement(); 执行sql，得到ResultSet 123//4.执行查询，得到结果集 String sql = \"select * from student\"; rs = st.executeQuery(sql); 遍历查询结果 12345678//5.遍历查询每一条记录 while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); System.out.println(\"id=\" + id + \", name=\" + name + \", age=\" + age); } 释放资源 1234567try { if (rs != null) { rs.close(); } } catch (SQLException e) { e.printStackTrace(); } 入门代码 123456789101112131415161718192021222324252627282930313233343536import com.mysql.cj.jdbc.Driver;import java.sql.*;public class MainTest { public static void main(String[] args) { try { //1.注册驱动 DriverManager.registerDriver(new Driver()); //2.建立连接 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/student?serverTimezone=GMT\", \"root\", \"root\"); //3.创建statement，跟数据库打交道，一定需要这个对象 Statement st = conn.createStatement(); //4.执行查询，得到结果集 String sql = \"select * from student\"; ResultSet rs = st.executeQuery(sql); //5.遍历查询每一条记录 while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); System.out.println(\"id=\" + id + \", name=\" + name + \", age=\" + age); } } catch (SQLException e) { e.printStackTrace(); } finally { //JDBCUtil为手写的JDBC工具类，release为释放资源的方法 JDBCUtil.release(conn, st, rs); } }} JDBC 工具类构建 资源释放工作的整合 驱动防二次注册 12345//DriverManager.registerDriver(new Driver());//Driver 这个类里面有静态代码快，只要类加载了就执行，所以等同于注册了两次驱动，其实没这个必要的。//静态代码块 ---&gt; 类加载了，就执行 DriverManager.registerDriver(new Driver());//最后形成以下代码即可Class.forName(\"com.mysql.cj.jdbc.Driver\"); 使用properties配置文件 在src底下声明一个资源文件 xxx.properties ，里面的内容如下： 1234driverClass=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost/student?serverTimezone=GMTuserName=rootuserPassword=root 在工具类里面，使用静态代码块读取属性 1234567891011121314151617181920static { try { //创建一个属性配置对象 Properties properties = new Properties(); //使用类加载器，去读取src低下的资源文件 InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); //导入输入流 properties.load(is); //读取属性 driverClass = properties.getProperty(\"driverClass\"); url = properties.getProperty(\"url\"); userName = properties.getProperty(\"userName\"); userPassword = properties.getProperty(\"userPassword\"); } catch (IOException e) { e.printStackTrace(); } } 数据库的CRUD sql insert 12INSERT INTO student (NAME, age) VALUES ('wangqiang', 28)INSERT INTO student VALUES (NULL, 'lidazui', 33) delete 1DELETE FROM student WHERE id = 5 query 1SELECT * FROM student update 1UPDATE student SET age = 38 WHERE id = 1 使用单元测试，测试代码 定义一个类，TestXXX，里面定义方法 testXXX 添加Junit的支持 在方法的上面加上注解，其实就是一个标记 1234@Test public void testQuery() { } 执行单元测试 DAO模式 Data Access Object 数据访问对象 新建一个Dao的接口，里面声明数据库访问规则 1234567public interface UserDao { /** * @Description 查询所有 **/ void findAll();} 新建一个Dao的实现类，具体实现早前定义的规则 123456789101112131415161718192021222324public class UserDaoImpl implements UserDao { @Override public void findAll() { Connection conn = null; Statement st= null; ResultSet rs = null; try { conn = JDBCUtil.getConnection(); st = conn.createStatement(); String sql = \"select * from user\"; rs = st.executeQuery(sql); while (rs.next()) { String userName = rs.getString(\"username\"); String password = rs.getString(\"password\"); System.out.println(\"userName:\" + userName + \", password=\" + password); } } catch (SQLException e) { e.printStackTrace(); } finally { JDBCUtil.release(conn, st, rs); } }} 直接使用实现 12345@Test public void tsetFindAll() { UserDao dao = new UserDaoImpl(); dao.findAll(); } Statement安全问题 Statement执行，其实是拼接sql语句的，先拼接sql语句，然后再一起执行 123456789String sql = \"select * from user where username = '\" + userName + \"' and password = '\" + password + \"'\";UserDao dao = new UserDaoImpl();dao.login(\"admin\", \"10000086' or '1=1\");SELECT * FROM user WHERE username='admin' AND password='10000086' or '1=1'//前面先拼接sql语句，如果变量里面带有了数据库的关键字，那么一并认为是关键字，不认为是普通的字符串rs = st.executeQuery(sql); PrepareStatement 该对象就是替换前面的statement对象 相比较以前的statement，PrepareStatement预先处理给定的sql语句，对其执行语法检查。在sql语句里面使用 ？占位符来替代后续要传递进来的变量。后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。 123456String sql = \"insert into user values (null, ?, ?)\";ps = conn.prepareStatement(sql); //给占位符赋值，从左到右数过来，1代表第一个问号，永远从1开始。ps.setString(1, userName);ps.setString(2, password); 总结： JDBC入门 抽取工具类 Statement CRUD 1演练CRUD DAO模式 1声明与实现分开 PrepareStatement CRUD 1预处理sql语句，解决上面Statement出现的问题","link":"/2019/04/25/JDBC/"},{"title":"Http协议 & Servlet","text":"Http协议 什么是协议 双方在交互、通讯的时候，遵守的一种规范、规则。 Http协议 针对网络上的客户端与服务器端在执行http请求的时候，遵守的一种规范。其实就是规定了客户端在访问服务器端的时候，要带上哪些东西，服务器端返回数据的时候，也要带上什么东西。 版本 1.0 ​ 请求数据，服务器返回后，将会断开连接 1.1 ​ 请求数据，服务器返回后，连接还会保持着。除非服务器或者客户端关掉。有一定的时间限制，如果都空着这个连接，那么后面会自己断掉。 演示客户端如何与服务器端通讯 在地址栏中键入网络地址或者是平常注册的时候，点击了注册按钮，浏览器都能显示出来一些东西。那么背地里到底浏览器和服务器是怎么通讯，它们都传输了哪些数据呢？ Http请求数据解释 请求的数据里面包含三个部分内容：请求行、请求头、请求体 请求行 1POST：请求方式，以post去提交数据 请求头 请求体 浏览器真正发送给服务器的数据 12发送的数据呈现的是key=value，如果存在多个数据，那么使用&amp;firstname=zhang&amp;lastname=san Http响应数据解析 响应的数据里面包含三个部分的内容：响应行、响应头、响应体 GET和POST的区别 请求路径不同。POST请求，在URL后面不跟上任何的数据，GET请求在地址后面跟上数据 带上的数据不同。POST请求会使用流的方式写数据，GET请求是在地址栏上跟数据 由于POST请求使用流的方式写数据，所以一定要一个Content-Length的头来说明数据的长度有多少。 POST 数据是以流的方式写过去，不会在地址栏上面显示。现在一般提交数据到服务器使用的都是POST。 以流的方式写数据，所有数据没有大小限制。 GET 会在地址栏后面拼接数据，所以有安全隐患。一般从服务器获取数据，并且客户端也不用提交上面的数据的时候，可以使用GET。 能够带的数据有限，1kb大小 Web资源在http协议当中，规定了请求和响应双方，客户端和服务器端。与Web相关的资源叫Web资源。 有两种分类： 静态资源 html、js、css 动态资源 servlet、jsp Servlet Servlet是什么？ 其实就是一个java程序，运行在我们的Web服务器上，用于接收和响应客户端的http请求。 更多的是配合动态资源来做，当然静态资源也需要使用到Servlet，只不过是Tomcat里面已经定义好了一个DefaultServlet。 Hello Servlet 得写一个Web工程，要有一个服务器。 测试运行Web工程 新建一个类，实现Servlet接口 配置Servlet，用意：告诉服务器，我们的应用有这么写个Servlet。 在web\\WEB-INF\\web.xml里面写上以下内容 12345678910&lt;!-- 向Tomcat报告，这个应用里面有个Servlet，名字叫做HelloServlet，具体的路径是com.wjh.servlet.HelloServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wjh.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 注册Servlet的映射。Servlet-name：找到上面注册的具体Servlet，url-pattern：在地址栏上的path --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet执行过程 找到Tomcat应用 找到项目 找web.xml，然后在里面找到url-pattern，看有没有哪一个pattern的内容是/helloServlet 找到servlet-mapping中的哪个servlet-name 【HelloServlet】 找到上面定义的servlet元素中的servlet-name中的【HelloServlet】 找到下面定义的servlet-class，然后开始创建该类的实例 继而执行该Servlet中的service方法 Servlet的通用写法12345Servlet（接口） |GenericServlet |HttpServlet（用于处理http的请求） 定义一个类，继承HttpServlet，复写doGet和doPost Servlet的生命周期 生命周期 从创建到销毁的一段时间 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 123//在创建该Servlet的实例时，就执行该方法。 //一个Servlet只会初始化一次，即init方法只会执行一次 //默认情况下是：初次访问该Servlet时，才会创建实例 service方法 12//只要客户端来了一个请求，那么就执行这个方法 //该方法可以被执行很多次。一次请求对应一次service方法的调用。 destroy方法 123//Servlet销毁的时候，就会执行该方法 //1.该项目从Tomcat里面移除 //2.正常关闭Tomcat就会执行 doGet和doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法，但是这两个方法，不一定会执行。 让Servlet创建实例的时机提前 默认情况下，只有在初次访问Servlet的时候，才会执行init方法。有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次方法可能会在init方法中逗留太久的时间。那么有没有方法可以让这个初始化的时机提前一点呢？ 在配置的时候，使用load-on-startup元素来指定，给定的数据越小，启动的时机就越早，一般不写负数，从2开始即可。 12345&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wjh.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; ServletConfig Servlet的配置，通过这个对象，可以获取Servlet在配置的时候的一些信息 1234567891011121314151617181920//ServletConfig 专门用于在配置Servlet的信息//1.得到Servlet配置对象ServletConfig config = getServletConfig();//获取到的是配置Servlet里面servlet-name的文本内容String servletName = config.getServletName();System.out.println(\"servletName = \" + servletName); //2.可以获取具体的某一个参数 String address = config.getInitParameter(\"address\"); System.out.println(\"address = \" + address); //3.获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) { String key = names.nextElement(); String parameter = config.getInitParameter(key); System.out.println(\"name = \" + key + \", value = \" + parameter); } 为什么需要有这个ServletConfig 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码我们不会，但是有人写出来了。它的代码放置在了自己的Servlet类里面。 刚好这个Servlet里面需要一个数字或者叫做变量值，但是这个值不能是固定的，所以要求使用到这个Servlet的公司，在注册Servlet的时候，必须要在web.xml里面声明init-params。 总结 Http协议 使用Http抓包看一看http请求背后的细节。 基本了解请求和响应的数据内容 12请求行、请求头、请求体响应行、响应头、响应体 GET和POST的区别 Servlet 会使用简单的Servlet 写一个类，实现接口Servlet 配置Servlet 会访问Servlet Servlet的生命周期 init service destroy ServletConfig 获取配置的信息，params","link":"/2019/04/24/Http协议-Servlet/"},{"title":"深入理解Java多线程与并发编程","text":"一、线程三大特性​ 多线程有三大特性：原子性、可见性、有序性 1.1、什么是原子性​ 即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性其实就是保证数据一致，线程安全的一部分。 1.2、什么是可见性​ 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 1.3、什么是有序性​ 程序执行的顺序按照代码的先后顺序执行。 二、Java内存模型​ 共享内存模型指的就是Java内存模型（简称JMM），JMM决定一个线程对共享变量的写入时，能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并且真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 ​ 总结：什么是Java内存模型：Java内存模型简称JMM，定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。 三、Volatile4.1、什么是Volatile​ Volatile关键字的作用是变量在多个线程之间可见。 1public volatile boolean flag = true; ​ 使用Volatile关键字可以解决线程之间的可见性，强制线程每次读取该值的时候都去“主内存”中取值。 4.2、Volatile非原子性123456789101112131415161718192021public class VolatileNoAtomicDemo { public static void main(String[] args) { for (int i = 0; i &lt; 10; i++) { VolatileNoAtomoic[] volatileNoAtomoics = new VolatileNoAtomoic[10]; volatileNoAtomoics[i] = new VolatileNoAtomoic(); volatileNoAtomoics[i].start(); } }}class VolatileNoAtomoic extends Thread { private static int count = 0; @Override public void run() { for (int i = 0; i &lt; 1000; i++) { count++; } System.out.println(getName() + \"---&gt;\" + count); }} 4.3、使用AtomicInterger原子类1234567891011class VolatileNoAtomoic extends Thread { private static AtomicInteger atomicInteger = new AtomicInteger(0); @Override public void run() { for (int i = 0; i &lt; 1000; i++) { atomicInteger.incrementAndGet(); //相当于count++ } System.out.println(getName() + \"---&gt;\" + atomicInteger); }} 4.4、volatile与synchronized区别​ 紧靠volatile不能保证线程的安全性。（原子性） ​ ①volatile轻量级，只能修饰变量。synchronized重量级，还可以修饰方法。 ​ ②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量时不会阻塞。synchronized不仅可以保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。 ​ 线程安全性：线程安全性包括两个方面：①可见性，②原子性。 五、ThreadLocal5.1、什么是ThreadLocal​ ThreadLocal提高一个线程的局部变量，访问某个线程拥有自己的局部变量。 ​ 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本变量。 1234567private ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;Integer&gt;() { //设置当前线程局部变量初始化值 @Override protected Integer initialValue() { return 0; } }; 5.2、ThreadLocal实现原理​ ThreadLocal通过map集合 Map.put(“当前线程”, 值) 六、线程池6.1、什么是线程池？6.2、线程池的作用6.3、线程池四种创建方式​ Java通过Executors（jdk1.5并发包）提供四种线程池，分别为： newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 1ExecutorService newCacheThreadPool = Executors.newCachedThreadPool(); newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 12//每次最多执行3个线程ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(3); newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor（一般不使用）：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序运行。 ​ 总结：线程池为无限大，当执行第二个任务时第一个任务已经完成，会重复用执行第一个任务的线程，而不用每次新建线程。","link":"/2019/04/24/深入理解Java多线程与并发编程/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/笔记/"}]}